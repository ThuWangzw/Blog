---
title: 2022秋招八股文笔记《操作系统4-进程线程》
date: '2022-04-28'
tags: ['操作系统', '笔记', '秋招', '八股文']
draft: false
summary: 2022秋招八股文笔记《操作系统4-进程线程》
---

1. 进程的状态
   1. 进程的状态包括：
      1. 基本状态：运行、就绪、阻塞、挂起
      2. 其它状态：创建、结束
      3. 挂起状态：表示进程的存在硬盘中而不是内存中
   2. 由于进程占用着内存，所以当进程阻塞时，操作系统一般会将其存储到硬盘中，需要再次运行时，才从硬盘中加载进内存，这称为进程的挂起
   3. 挂起包括：
      1. 阻塞挂起：进程存放在硬盘，等待阻塞结束
      2. 就绪挂起：进程存放在硬盘，加载到内存后可以立即执行
   4. 挂起的原因有：计算机的资源不足；进程调用 sleep；进程被用户手动挂起
2. 进程的控制结构 PCB
   1. 进程和进程控制块 PCB 一一对应，PCB 包括：
      1. 进程描述信息：进程标识符【唯一确定进程】、用户标识符
      2. 进程状态信息、管理信息：进程当前的状态和进程的优先级
      3. 资源信息：页表、打开的文件、设备
      4. CPU 信息：寄存器的值
   2. PCB 的组织形式：
      1. 通过链表组织，将相同状态的 PCB 构成一个队列，如就绪队列、阻塞队列等
      2. 也可以使用索引的形式组织，但是链表更加灵活
3. 进程的管理
   1. 进程的创建：
      1. 为进程分配一个进程标识符，并申请一块空白的 PCB
      2. 为进程分配资源（页表？）
      3. 初始化 PCB
      4. 加入就绪队列进行调度
   2. 进程的终止
      1. 进程的终止方式有：正常终止、异常终止、信号 kill
      2. 进程的终止过程是：
         1. 查找相应的 PCB
         2. 停止进程执行、释放资源
         3. 子进程处理：windows 会终止子进程；linux 会将子进程交给 1 号进程
         4. 将 PCB 从队列中删除
   3. 进程的阻塞
      1. 找到进程相应的 PCB
      2. 保存进程执行的现场，转为阻塞状态
      3. 加入阻塞队列
   4. 进程的唤醒和进程的阻塞相反
      1. 进程是不能唤醒自己的，需要另一个进程唤醒它
4. 进程的上下文切换
   1. 首先，什么是 CPU 的上下文切换
      1. 首先，什么是 CPU 的上下文：CPU 的寄存器和程序计数器
      2. CPU 的上下文切换就是把前一个任务的寄存器和程序计数器保存起来，加载新任务的寄存器和计数器
   2. 进程由内核进行管理和调度的，因此进程的上下文切换只能发生在内核态
   3. 进程上下文切换的过程：进程的上下文保存、新进程的上下文加载。（保存和加载都是 PCB 中的信息）
5. 为什么需要线程？
   1. 能够像进程一样并发执行
   2. 能够共享地址空间
6. 线程的特征
   1. 线程之间共享代码段、数据段、打开的文件等资源，但是具有独立的寄存器和栈，方便各自的控制流是相互独立的。
   2. 线程崩溃了，一般整个进程都会崩溃，java 会拦截对应的信号，所以 java 中线程崩溃不会引起进程的崩溃
   3. 进程是资源分配的基本单位，线程是调度的单位
7. 线程和进程相比，在开销上有什么区别？
   1. 线程创建的开销更小，因为进程创建需要分配资源，例如地址空间、文件资源等。线程只有寄存器和栈
   2. 同理，线程销毁的开销也小
   3. 同进程内的线程切换比进程切换的开销小。主要是因为同进程的线程之间的切换不会切换页表，而页表切换会导致 TLB 缓存失效，代价比较大
   4. 线程之间数据传递更方便
8. 线程的上下文切换：分为两种
   1. 同进程的线程切换：不涉及进程的上下文切换，只切换栈、寄存器等线程独有的数据
   2. 不同进程的线程切换：相等于进程切换
9. 线程的实现方式：用户线程、内核线程、轻量级进程。
   1. 用户线程：操作系统不会感知到线程的存在，而是由用户态的线程库来实现。
      1. 用户线程的优点：
         1. 可以在不支持线程的操作系统上运行
         2. 用户线程的切换无需进入内核态，因此速度会比内核线程快
      2. 用户线程的缺点
         1. 一个线程阻塞，同一进程的其它线程也无法执行
         2. 一个线程如果不主动释放 cpu，其它线程永远无法执行
         3. 操作系统只能感知到进程，因此如果一个进程的线程很多，那么分到每一个线程的时间片会很少
   2. 内核线程：操作系统感知的线程
      1. 内核线程的优点：
         1. 利用了多核的优势，一个进程的多个线程可以在多个核上同时执行
         2. 避免了用户线程中多个线程平分一个进程时间片的问题
         3. 一个线程阻塞，其它线程可以继续执行
      2. 内核线程的缺点
         1. 所有线程的 TCB 都是由内核来维护，空间开销太大了
         2. 内核线程的创建、销毁、调度由内核完成，时间开销太大
   3. 内核线程核用户线程混用：LWP 轻量级进程，在 linux 使用。
      1. 每个 LWP 和每个内核线程一一对应，每个进程有若干个 LWP，每个 LWP 与用户线程是多对多的关系
      2. 对于 linux 没有线程的概念，
   4. ![thread](/static/images/thread.png)
10. 进程调度：
    1. 分类：抢占式调度和非抢占式调度
       1. 区别在于是否有时间片机制【CPU 发出时钟中断】，导致进程有从运行态到就绪态的变化。
    2. 调度原则
       1. CPU 利用率：发生 IO 事件时调度进程
       2. 吞吐率：如果有长任务一直在执行，吞吐率将会下降【单位时间完成的进程数】
       3. 周转时间：进程的等待时间+实际运行时间=周转时间，周转时间要尽量短
       4. 等待时间：就绪队列中进程的等待时间，越短越好
       5. 响应时间：交互式的进程越快越好，比如鼠标键盘操作
11. 调度算法
    1. 先来先服务（队列）
    2. 短作业优先（优先队列）
    3. 高响应比优先调度
       1. 权重=（等待时间+要求服务时间）/要求服务时间
    4. 时间片轮转，20-50ms
    5. 最高优先级调度
       1. 提前设定好优先级
       2. 分为静态优先级和动态优先级，例如进程运行一段时间后优先级下降
       3. 分为抢占式和非抢占式，即如果有更高优先级的进程，那么当前运行的进程是否停止
    6. 多级反馈队列
       1. 相当于时间片轮转+最高优先级队列
       2. 优先级越高，时间片越短
       3. 抢占式调度
       4. 每个进程刚创建后，加入第一级队列，如果时间片内未执行结束，加入第二级队列，以此类推
    7. linux 的调度算法：CFS 完全公平调度器
       1. 为每个进程定义一个 nice 值
       2. 定义一棵红黑树，每次取得 nice 值最小的进程即可
12. 一个进程能创建多少线程
    1. 与两个参数有关：首先是虚拟空间的大小，其次是系统设置的一些参数
    2. 在 32 位地址空间下，虚拟空间有 4G，除去内核空间，再除以每个线程的大小，约有几百个线程
    3. 在 64 位地址空间下，理论上有无限个线程，但是还要受影响：
       1. 最大线程数；PID 最大值（每个线程都有个 PID）
       2. 性能限制：CPU 瓶颈、内存瓶颈

---
title: 2022秋招八股文笔记《操作系统3-内存管理》
date: '2022-04-27'
tags: ['操作系统', '笔记', '秋招', '八股文']
draft: false
summary: 2022秋招八股文笔记《操作系统3-内存管理》
---

1. 为什么要有虚拟内存
   1. 避免进程直接操作物理地址，不同进程之间就会产生操作同一物理地址的危险
2. 分段虚拟地址
   1. 将虚拟地址划分为若干段（代码段、数据段、堆段、栈段），每一段有一个段号
   2. 操作系统维护一张段表，可以通过段号来查询相应的段表项
   3. 段表项中存储了相应基地址、空间大小和权限
3. 分段虚拟地址的缺点
   1. 造成了较大的内存碎片。不同进程占用的物理内存如果不连续，就会产生内存碎片。
   2. 由于内存碎片的产生，需要进行内存交换。即进行先将进程写入硬盘，再写回内存，以使内存连续的“内存交换”操作，这一操作由于设计读写硬盘，因此非常慢。
4. 分页虚拟地址
   1. 分页的意思是：把物理内存和虚拟内存都划分成一块块页，在 linux 中每个页为 4kb
   2. 通过 MMU 来维护一张页表【虚拟表号到真实表号的映射】，来建立虚拟地址到物理地址的映射
5. 为什么它能解决分段虚拟地址的缺点？
   1. 内存碎片问题：由于整个物理内存都被划分成一个个页，因此不存在进程之间的碎片
   2. 内存交换：如果因为内存空间不足，而产生内存交换，只需要交换部分页即可（称为内存的换出和换入）
6. 简单的分页虚拟地址有什么缺点？
   1. 浪费空间。
   2. 对于每个进程，都需要维护这样一张【完整的】页表，对于 32 位地址来说，需要 2^20 个页，每个页表项 4b，则需要每个进程 4mb 的空间，对于多进程而言，这个代价太大
7. 如何解决？
   1. 多层分页，因为很少有进程能够用完整个地址空间
   2. 32 位的分为 2 层，64 位的分为 4 层
8. 多层分页【多级页表】带来的问题是：一次内存读写，需要多次访问页表，带来性能瓶颈，根据局部性原理，设计了 TLB 缓存，将常用的页表缓存进来【进程切换比线程慢的主要原因就是带来了 TLB 失效】【这里：如何从进程的切换扯到虚拟内存上来，为什么 TLB 失效】
9. 段页式：先分段，每个段有一张页表。这是 CPU 的设计，然而 linux 中只有一个段，因此 linux 用的是页式的
10. linux 虚拟地址空间的分布：
    1. 高位是内核空间，低位是用户空间。其中不同进程的内核空间的物理地址实际是一样的。
    2. 用户空间中，最低位是代码段、数据段，其次是堆自底向上生长，栈自顶向下生长。
    3. 堆和栈之间还有一部分文件映射段，自底向上生长，存储的是【动态链接库、虚拟内存等】
11. 栈的最大值是固定的，linux 中固定为 8MB，超出会 stackoverflow
12. 每个线程都有各自的栈，这是怎么实现的？
    1. 首先，主线程【也就是所谓的进程】，栈就是内存中的栈空间
    2. 其它线程的栈，实际上都在堆空间中
13. malloc 是如何申请内存的？
    1. 首先，malloc 函数并不是系统调用，而是 c 自己实现的库函数，它实际用的是 brk 和 mmap 两个系统调用。
    2. malloc 分配的是虚拟内存，也就是说，如果申请了内存而不访问，是不会占用物理内存的
    3. brk 是从堆区申请空间的，mmap 是通过私有匿名映射从文件映射区申请空间
    4. 两者的区别是：
       1. brk 实际上是把指针不断往高地址推来申请内存的，这种方式下会带来内存碎片，即高地址的内存释放之后，低地址的内存才能释放
       2. mmap 申请的内存可以单独释放。
    5. 因此 malloc 的工作原理为：
       1. 申请的内存小于 128k 时，使用 brk，并且 malloc 会维护 brk 申请的内存的内存池，这样重复的申请小内存不需要再系统调用。
       2. 申请的内存大于 128k 时，使用 mmap，每次释放时，也会 立刻还给操作系统
    6. 因此对于小内存申请来说，使用 brk 比较好，因为 malloc 维护了内存池，不需要频繁系统调用，也不会产生缺页中断。如果使用 mmap 频繁申请小内存的话，就会带来频繁的系统调用和缺页中断
14. free 只知道释放内存的起始地址，怎么知道要释放多少内存的？
    1. 因为申请的内存区域中有记录此次申请的元信息。
       ![内存](/static/images/memory.png)

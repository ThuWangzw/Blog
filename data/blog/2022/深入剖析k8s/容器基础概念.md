---
title: 2022秋招八股文笔记《云原生2-容器基础概念》
date: '2022-04-20'
tags: ['云原生', '笔记', '秋招', '八股文']
draft: false
summary: 2022秋招八股文笔记《云原生2-容器基础概念》
---

1. 容器的实现最主要的是用了 namespace 和 cgroups 两个概念分别做【隔离】和【限制】
2. namespace 是一种障眼法，使得进程只能看到 namespace 内的资源，如 pid namespace 的使用使得容器的进程认为自己是 pid=1 的一号进程。另外还有其余的 namespace 如 pid, uts, network, user, mount, ipc, cgroup..
   1. 从这一角度上看，并没有真正的容器在被运行，被启动的还是原来的进程，只是加了一系列的 namespace 参数而已
   2. 使用 docker run -it busybox /bin/sh 启动 shell，然后在容器外部使用 ps 查看进程，发现了 docker run =it busybox /bin/sh 和/bin/sh 两个进程，后者应该是被隔离的进程
3. 从隔离角度看，容器与虚拟机比较：
   1. 优点：
      1. 从空间上看，虚拟机需要一个 Guest OS，占用了较大空间，而容器不需要 Guest OS
      2. 从时间上看，虚拟机会拦截进程的系统调用并进行处理，再交给宿主机执行，会浪费性能，而容器中的进程是直接执行在宿主机上的
   2. 缺点：容器隔离的不够彻底
      1. 在同一宿主机上的多个容器进程使用的都是宿主机的内核
      2. 在 linux 中，很多资源不能被 namespace 化，例如时间，容器进程可以使用 settimeofday 来修改时间，这会影响其他进程，不过可以使用 seccomp 等技术来对系统调用进行过滤，这属于在隔离和性能之间的平衡
4. 限制概念的实际用的是 linux 的特性"cgroup"，全称为 Control group，它是在/sys/fs/cgroup 下的一系列文件，对于每种资源【称为子系统】都有相应的文件夹，在对应的文件夹下面新建文件夹称为【控制组】，在该文件夹下可以对对应资源所占用的 quota 进行设置，即为设置好了控制组。在启动进程后，将 pid 填入控制组即可。
5. cgroup 的限制也是有限的。例如在容器中使用 top 命令查看 CPU、内存使用情况，实际使用的是宿主机的/proc 目录下的信息，因此查看的是宿主机的使用情况，而不是 cgroup 限制之后的，如果进程会根据这些信息决定自己的资源占用，那么会出现 OOM 等问题。解决办法是不要挂载/proc，而是使用 lxcfs 来管理
6. 容器是单进程模型，即：同一容器中不能跑两个毫不相干的进程，虽然可以使用 systemd 等方法，但是这违背了容器的设计思想，即容器与进程的生命周期应该一致，否则会出现进程挂掉然而容器正常运行的情况，不利于编排系统的处理。
7. 容器文件系统的隔离：
   1. 首先，使用 mount namespace 进行隔离。实现方法为：在容器启动后，mount 容器的根目录到一个指定的文件夹，则容器的所有对文件的操作都是在此文件夹中实现的。在 shell 中这个操作可以用 chroot 完成，被 mount 为根目录的文件夹称为 rootfs
   2. rootfs 解决了容器的一致性问题。即整个操作系统都被打包了。
   3. 进一步的，为了解决 rootfs 的版本管理，使用了 unionFS 来做分层。
      1. 每个镜像都由只读层、init 层和读写层组成。
      2. 只读层的挂载方式都是只读的。每次对镜像的文件做了操作，都会在读写层中体现。如果删除了文件，采用的是 whiteout 方式，即产生一个类似.wh.foo 的文件来标记此文件已被删除，而不是真正删除了文件。因此，删除文件并不会使得镜像变小！
      3. init 层存放了 hosts 之类的仅对当前容器有效的文件，而不希望它被 docker commit 提交
8. 如何使进程加入到另一个 namespace 中：
   1. 使用 setns 系统调用即可
9. 事实上，docker exec 可以在一个容器中开启一个新的进程，即令一个新进程加入到已有进程的 ns 中，靠的也是这个，加入之后在/proc/xxx/ns 中可以看到，两个进程的 namespace 是相同的
10. Docker volume 原理
    1. 可以在启动容器时，使用-v 参数指定将一个宿主机上的文件夹绑定挂载到容器中
    2. 实现的原理其实就是 linux 的绑定挂载功能，时机是在开启 mount namespace 后、chroot 之前。
    3. 它满足以下几点
       1. 在容器中对绑定的文件夹采取的操作，也同时会体现到宿主机中【这当然是我们使用 volume 的预期】
       2. 同时，这个被绑定的文件夹的内容不会被 docker commit 提交，即它的增删改查不会被分层管理
          1. 这是因为 docker commit 是在宿主机中进行的，而不是在容器中进行的，宿主机认为该文件夹没有被绑定，是一个空文件夹
          2. 因此 docker commit 会提交一个空的绑定文件夹
    4. Docker volume 要结合 linux 的 inode 和 dentry 来理解，绑定挂载实际上是把被绑定文件夹的 dentry 指向了绑定文件夹的 inode
11. docker 容器由三个主要技术组成：namespace, linux cgroups, rootfs。前两种是容器运行时，rootfs 是容器镜像。
12. 相比于 docker compose+swarm， k8s 为什么有优势：因为 k8s 借鉴了 borg 项目的经验，更抽象的总结了不同的任务(job, cronjob)等等，使用声明式的 api。因此前者叫调度，后者叫编排。

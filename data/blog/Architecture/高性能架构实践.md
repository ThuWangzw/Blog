---
title: 《高性能架构实践》阅读笔记
date: '2021-08-07'
tags: ['架构', '笔记']
draft: false
summary: 《高性能架构实践》阅读笔记
---

暑假抽空读了从图书馆借的《高性能架构实践》这本书。这本书涵盖了很多常见的业务场景和相应的技术，对相关问题解释的很清楚明白，非常适合作为架构方面的科普书来读。像我这样对业界缺乏了解的学生，比较适合读这本书对高性能架构有初步的了解，如果有喜欢的方向，再去读相应的更详细、更专业的书籍或文档。

这里我放的是自己阅读时记的笔记，仅供个人将来遗忘时的备份，可读性较差。

<h3>总览</h3>

1. 衡量高性能主要看两大方面
   1. 效率：时间效率、资源效率、容量（如带宽、数据库、并发用户数
   2. 可靠性：成熟度、可用性、容错性、可恢复性
2. 相关指标 3. 吞吐量（TPS QPS 4. 并发数：通常理解为与性能无关，是用户的行为 5. 平均响应时间 6. 各种可靠性的指标
3. 并发数对吞吐量的影响 7. 并发数越高，吞吐量一开始越高、然后持平，最后下降
4. 并发数与平均响应时间 8. 并发数越高，平均响应时间越高。与指数分布类似
5. 平均响应时间与并发数 9. 系统整体的并发数不受任何指标的影响 10. 但是系统内部并发数会受影响，平均响应时间越长，并发数越高

<h3>分流设计</h3>

1. CDN 内容分发网络的基本概念
   1. CDN 网络中有源站和 CDN 节点。用户的所有请求会被转发到 CDN 节点，然后 CDN 节点会缓存静态资源，并把动态请求发回给源站。
2. CDN 的原理
   1. 主要解决的问题是：如何捕获发给源站的请求，然后发到 CDN 节点上
   2. 这与 DNS 有关
      1. 首先在 DNS 服务提供商处把自己的域名映射给 CDN 提供商的域名。
      2. CDN 提供商的域名的解析服务是由 CDN 提供商自己来维护的
      3. 这样，提供商就可以根据用户的 IP 等规则，来决定返回给用户哪个 CDN 节点的 IP
      4. 最终，用户请求的是源站的地址，拿到的却是 CDN 节点的 IP
3. 多地址直连
   1. 模拟 CDN 的原理，在不用 CDN 或者有多个源站的情况下分流
   2. 将用户的完整请求分为两部分：获取服务地址、请求服务
4. 反向代理
   1. nginx 如何做反向代理？用 upstream 属性可以设置上游服务器，并给他们分配权重。
   2. nginx 有四种反向代理方式：轮询、加权、哈希和自定义（lua 脚本）

<h3>服务并行设计</h3>

当请求到达系统之后，如何解决系统的高并发问题？主要解决的问题是：如何解决用户的多个请求可能会到不同节点的问题？

1. 无状态集群：要求功能是无状态的，这样请求到哪个节点都可以。但是这种集群的功能非常受限
2. 单一服务节点集群：为每个用户指定特定的服务节点。比如游戏注册选区，或者用 cookie。但是节点互相隔离，无法备份，容错性很差
3. 信息共享的节点集群：节点本身无状态，用户信息存储在信息池中（如 redis 数据库），但是整体的性能受到信息池的限制。
4. 信息一致的节点集群：每个节点分别存储信息，但是各个节点之间会同步

分布式系统：将单体应用分开
微服务系统：进一步分开

<h3>运算并行</h3>

1. 运算级别的并行有三级：多进程、多线程和多协程
2. 多进程主要用于资源隔离，很简单，只要在多个端口开多个服务即可
3. 多线程：在并行和并发时都可以提高效率，并发时可以提高 CPU 的利用率
4. 多线程两种使用场景：
   1. 提高效率
   2. 异步操作：比如后端在进行长耗时操作时，主线程先返回前端，新开一个线程做耗时操作
5. 多线程资源竞争
   1. 禁止并发修改
   2. 线程安全对象（原子操作
   3. 线程独享资源
6. 多线程同步
   1. 分总式：等所有子线程结束，总线程才继续执行
   2. 栅栏式：设立一个放行栅栏，等栅栏处的线程数量达到阈值时，栅栏才放行
   3. 总分总
   4. 信号量
7. 多协程
   1. 相当于语句的跳转，因此协程之间的切换效率很高
   2. 不需要锁，因为同一线程的不同协程是并发不是并行的

<h3>输入输出设计</h3>

1. 同步 vs 异步
   1. 关注的是消息通信的机制
   2. 同步指接收方等命令执行结束之后，再返回给调用方
   3. 异步指接收方接收到消息之后，立刻返回给接收方，等执行结束后，再通知接收方已经结束
2. 阻塞 vs 非阻塞
   1. 关注的是调用方的行为
   2. 阻塞指的是调用方等接收方返回之后，再执行下一步操作
   3. 非阻塞指的是调用方不用等待接收方返回结果
3. 一般有三种 IO 模型（同步）阻塞式、（同步）非阻塞式，异步
4. 实际的 IO 模型
   1. 阻塞式 IO
      1. 如果输入输出很多，那么每个 IO 都对应一个线程，线程的维护占用许多内存，线程的切换占用 CPU 时间片，因此效率不高
   2. 非阻塞式（轮询，效率不高
      1. 在接收阶段可以轮询，在复制阶段读数据
      2. 每次读都能立刻返回，但是结果可能是空的、满的、不完整的这三种情况之一
      3. 主要缺点是：在等待阶段需要轮询，浪费 CPU 时间
   3. 信号驱动式
   4. 复用 IO（一个监听函数监听多个 IO）相比于阻塞式，要监听的 IO 越多，效率比阻塞式 IO 越高
   5. 异步 IO

<h3>数据库设计与优化</h3>
1. 为什么数据库通常对系统性能影响大
	1. 涉及到IO读写
	2. 通常因为数据同步设计成单点，并发压力大
	3. 数据量随着时间延长而增加
2. 如何设计数据库？
	1. 数据库选型
	2. 存储引擎选型
	3. 表结构设计
	4. 其余优化（如语句优化
3. 关系型数据库范式的设计
	1. 数据库的设计是有一定的规范的，称为范式设计
	2. 超键、候选键、主键是逐级包含关系
		1. 超键是能唯一标识记录的属性集
		2. 候选键是不含有多余属性的超键
		3. 主键是设计者从候选键中选择的
	3. 函数依赖：x -> y指的是x相同时y一定相同
	4. 部分函数依赖与完全函数依赖
		1. 部分依赖指的是x中有多余的属性
		2. 完全函数依赖中没有多余的属性
	5. 平凡函数依赖与非平凡函数依赖
		1. 当y是x的子集时，依赖是平凡的
	6. 传递函数依赖
		1. 依赖可以传递
4. 第一范式1NF
	1. 数据库的属性必须是原子的，不可再分
5. 第二范式2NF
	1. 数据库的非主属性必须完全依赖于候选键
	2. 否则，将会导致数据冗余、数据不一致
6. 第三范式3NF
	1. 任何非主属性不依赖于其它非主属性
	2. 否则存在数据冗余与数据不一致
7. 修正的第三范式BCNF
	1. 任何非主属性不能传递依赖于其它非主属性
	2. 因为3NF没有规定主属性不能依赖于非主属性，因此可能存在非主属性传递依赖于其它非主属性
8. 第四范式
	1. 不允许有非平凡、非函数依赖的多值依赖
	2. 可以简单理解成不能有数组？
9. 第五范式
	1. 要求每个连接依赖由且仅由候选键推出
	2. 即，不能进一步拆分成候选键更少的表
10. 反范式设计
	1. 有的时候为了提高性能，要进行反范式设计
11. 哈希索引
	1. 指定一个属性后，可以对该属性建立哈希索引
	2. 索引可以加载到内存中，因此读写速度会快
	3. hash索引只能计算等值索引，不能进行区间索引、排序等
12. b树索引
	1. 出度为d，数据量为N, 时间复杂度为log_dN，因此d越大越好
	2. 但是出度不能无限增大，因为每个节点的大小要限制在4kb之内，因为一张页表是4kb，这样可以保证一个节点可以在一次IO操作中被读取
	3. b-树的非叶节点也有数据，b+树只在叶节点有数据，因此b+树的d可以取得更大
	4. b+树的叶节点可以存真实数据的指针，如myisam，也可以直接存真实数据，如innodb存的是主键值
13. 位图索引
	1. 适用于枚举类型，每个属性的每种取值都构成向量的某一维度(0/1)
	2. 使用向量的位运算，可以快速筛选出所选的数据
14. 索引生效分析
	1. 可以使用describe或者explain来查看索引在当次查询中是否生效
15. 按照使用场景对索引进行分类
	1. 唯一索引：一个索引值不可能对应两个元素
	2. 主键索引
	3. 聚集索引：指的是索引顺序与数据实际存储的物理顺序相同，每个表只有一个聚集索引，因为物理顺序只有一种，一般是主键索引
	4. 联合索引：多个属性
	5. 过滤索引：不对所有记录进行索引
	6. 全文索引：对记录进行分词再索引
	7. 前缀索引：属性太长可以用前缀索引
16. 索引常见的失效场景
	1. 对索引属性进行类型转换或者计算
	2. 联合索引：
		1. 如果检索中所有属性都用到了，那么索引是生效的
		2. 否则，参考联合索引的最左前缀原则，只有创建索引时的第一个属性才有全局索引
	3. Isnull：因为null的记录不参与索引，可以给null记录设置默认值
17. 索引的缺点
	1. 占用空间，不过可以忽略
	2. 每次写数据库都要对应更新索引，因此不要对写操作多的属性建立索引
18. 数据库的锁
	1. 读是不需要加锁的，只有写需要加
	2. 乐观锁
		1. 是一种策略，而不是实际的锁
		2. 先读数据以及数据的版本号，进行修改后，尝试写入，如果版本号一致则写入成功，否则写入失败，重试
		3. 版本号可以用版本号属性（时间戳）、被修改属性的值或者记录所有属性的值（或其哈希）
		4. 它适合写入少的情况
	3. 悲观锁
		1. 读锁，当有读锁时，其余操作者可以继续加读锁
		2. 写锁，当有写锁时，其余操作者不能加读、写锁
		3. 只有读写锁，会有死锁问题，当两个操作者同时持有读锁，并想要修改为写锁时，就会出现死锁
		4. 更新锁：当有更新锁时，其余操作可以读，但是不能加更新锁或者写锁。表示对写锁的预定
		5. 悲观锁根据作用范围还可以再分为：行锁、页锁、表锁
19. 大数据下，如何优化数据库
	1. 最简单的是表分区：可以存储大量数据，并且通过分布式缓解读写压力
	2. 分库分表：将数据库也分开
	3. 读写分离：主数据库专门进行写操作，从数据库进行读操作
		1. 路由操作
		2. 读写分离

<h3>缓存设计</h3>

1. 缓存也是要考虑成本的
   1. 缓存的查询需要时间，还可能需要反序列化的时间
2. 缓存的键值可以用哈希值，但是有极小的概率发生碰撞
3. 缓存的值分两种：序列化存储和对象存储，其中对象存储因为不需要序列化、反序列化，所以更快
4. 缓存如何更新
   1. 时效性更新，假设缓存一段时间内不同步的影响也不大
   2. 实时更新
      1. 读照常，写的时候，先写入数据提供方，再清除缓存
      2. 读写都在缓存上进行，由缓存进行数据同步
5. 缓存如何清理
   1. 缓存越大，越容易命中，但是越大的缓存，占用的空间越大，因此需要及时清理
   2. 时效性清理，即每条记录都有失效时间
   3. 数目阈值式清理：很像操作系统中缓存的清理，用 FIFO 或者 LRU
   4. 强弱引用：当内存充足时，弱引用的缓存不被清理，当内存不充足时，清理弱引用缓存
6. 缓存常见的问题
   1. 缓存穿透：如果数据提供方也不存在缓存中的数据，每次请求仍然都会经过缓存-》数据提供方，导致数据提供方承受力压力
   2. 缓存雪崩：大量缓存突然失效。常见于时效性清理或者强弱引用清理缓存
   3. 缓存击穿：一个高频率的缓存突然失效
   4. 缓存预热：缓存启动之后，总需要一段时间来充满
7. 缓存的位置
   1. 客户端缓存
   2. 静态缓存
   3. 服务缓存
   4. 数据库缓存
8. 写缓存
   1. 主要功能是限流

<h3>应用保护</h3>

1. 隔离
   1. 用线程池来限制资源，防止资源开销过大
2. 限流
   1. 时间窗、漏桶、令牌
3. 降级：改用一些策略来降低系统的响应时间
4. 熔断

<h3>前端高性能</h3>

1. 主要包括资源下载和页面解析两步
2. 资源下载优化
   1. 压缩
   2. 减少连接数
      1. 长连接
      2. 长轮询
      3. Websocket
   3. 页面解析
   4. 懒加载
   5. 预操作
      1. Preload
      2. prefetch

<h3>架构设计</h3>

1. 管道过滤器：流式处理，unix 中的|
2. 面向对象架构
3. 基于组件架构
4. 事件驱动架构
5. 分层架构，如网络的 OSI 模型
6. CS 架构
   1. 服务端仅提供计算和数据，客户端需要进行数据处理
7. 三层 CS 架构
   1. 数据层存储数据，应用服务器进行逻辑计算，客户端进行表示
   2. 可以理解成手机上的 APP
8. BS 架构
   1. 浏览器架构
   2. 和三层 CS 很像，但是区别是不需要升级客户端（只需要升级网页即可
   3. 比如，手机 APP 需要更新升级，但是浏览器中的网页不需要
